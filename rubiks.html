<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Realistic Dynamic Rubik's Cube</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: radial-gradient(circle at center, #333333 0%, #000000 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
        }

        #ui-container {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(8px);
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            pointer-events: none;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .panel {
            pointer-events: auto;
            margin-bottom: 15px;
        }

        h2 {
            margin: 0 0 10px 0;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #aaa;
            font-weight: 600;
        }

        button {
            background: rgba(255, 255, 255, 0.05);
            color: #ddd;
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 8px 10px;
            margin: 2px;
            cursor: pointer;
            border-radius: 6px;
            font-weight: 600;
            transition: all 0.2s ease;
            font-size: 0.9rem;
        }

        button:hover {
            background: rgba(255, 255, 255, 0.15);
            color: white;
            border-color: rgba(255, 255, 255, 0.3);
        }

        button:active {
            transform: translateY(1px);
        }

        .control-group {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 4px;
            margin-bottom: 10px;
        }

        .action-group {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }

        .special-btn {
            background: linear-gradient(145deg, #2196F3, #1565C0);
            border: none;
            color: white;
        }

        .special-btn:hover {
            background: linear-gradient(145deg, #42A5F5, #1E88E5);
            box-shadow: 0 4px 15px rgba(33, 150, 243, 0.3);
        }

        .solve-btn {
            background: linear-gradient(145deg, #4CAF50, #2E7D32);
            border: none;
            color: white;
        }

        .solve-btn:hover {
            background: linear-gradient(145deg, #66BB6A, #388E3C);
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
        }
    </style>
</head>

<body>

    <div id="ui-container">
        <div class="panel">
            <h2>Manual Controls</h2>
            <div class="control-group">
                <button onclick="queueMove('L', 1)">L</button>
                <button onclick="queueMove('U', 1)">U</button>
                <button onclick="queueMove('R', 1)">R</button>
                <button onclick="queueMove('L', -1)">L'</button>
                <button onclick="queueMove('U', -1)">U'</button>
                <button onclick="queueMove('R', -1)">R'</button>
                <button onclick="queueMove('F', 1)">F</button>
                <button onclick="queueMove('D', 1)">D</button>
                <button onclick="queueMove('B', 1)">B</button>
                <button onclick="queueMove('F', -1)">F'</button>
                <button onclick="queueMove('D', -1)">D'</button>
                <button onclick="queueMove('B', -1)">B'</button>
            </div>
        </div>

        <div class="panel">
            <h2>Actions</h2>
            <div class="action-group">
                <button class="special-btn" onclick="scrambleCube()">Scramble</button>
                <button class="solve-btn" id="btn-solve" onclick="solveCube()">Auto Solve</button>
            </div>
        </div>

        <div class="panel">
            <h2>Patterns</h2>
            <div class="action-group">
                <button onclick="applyPattern('checkerboard')">Checkerboard</button>
                <button onclick="applyPattern('centerswap')">Center Swap</button>
            </div>
        </div>
        <div class="panel" style="margin-top: 20px; font-size: 0.8rem; color: #888;">
            Rotate view to see dynamic lighting.
        </div>
    </div>

    <div id="canvas-container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/RoundedBoxGeometry.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>

    <script>
        // --- CONFIGURATION ---
        const CUBE_SIZE = 1;
        const SPACING = 0.006;
        const TOTAL_SIZE = CUBE_SIZE + SPACING;

        // Realistic Sticker Colors
        const COLORS = {
            R: 0xc41e3a, L: 0xff5800, U: 0xeaeaea, D: 0xffd500, F: 0x009b48, B: 0x0046ad, CORE: 0x0a0a0a
        };

        let scene, camera, renderer, controls;
        let cubies = [];
        let isAnimating = false;
        let moveQueue = [];
        let moveHistory = [];
        let pivot = new THREE.Object3D();
        const stickerMaterials = {};
        let coreMaterial;

        function init() {
            const container = document.getElementById('canvas-container');

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            // PCFSoftShadowMap provides softer, more realistic shadow edges
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            // Filmic Tone Mapping handles bright highlights better, preventing color blowout
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.1;
            container.appendChild(renderer.domElement);

            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000000, 15, 30); // Dark fog to fade out floor

            camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(7, 6, 9);
            camera.lookAt(0, 0, 0);
            // IMPORTANT: Add camera to scene so lights attached to it render correctly
            scene.add(camera);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.08;
            controls.minDistance = 4;
            controls.maxDistance = 25;
            controls.autoRotate = false; // Ensure it doesn't spin automatically

            // Setup the dynamic lighting
            setupLighting();

            createFloor();
            createRealisticMaterials();
            createRubiksCube();
            scene.add(pivot);

            window.addEventListener('resize', onWindowResize);
            animate();
        }

        function setupLighting() {
            // 1. Base Ambient Light (attached to scene)
            // Provides subtle fill light so shadows aren't pitch black.
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
            scene.add(ambientLight);

            // 2. Main "Key" Light (ATTACHED TO CAMERA)
            // This is the crucial change for dynamic lighting. 
            // The light moves with the viewer.
            const keyLight = new THREE.DirectionalLight(0xffffff, 1.2);
            // Position is relative to the camera. Offset slightly to the right and top.
            keyLight.position.set(4, 6, 4);
            keyLight.castShadow = true;

            // High resolution shadow map for crisp details
            keyLight.shadow.mapSize.width = 2048;
            keyLight.shadow.mapSize.height = 2048;

            // Tight shadow camera frustum around the cube for maximum sharpness
            keyLight.shadow.camera.left = -3;
            keyLight.shadow.camera.right = 3;
            keyLight.shadow.camera.top = 3;
            keyLight.shadow.camera.bottom = -3;
            keyLight.shadow.camera.near = 0.1;
            keyLight.shadow.camera.far = 30;

            // Bias adjustments to prevent "shadow acne" on the rounded surfaces
            keyLight.shadow.bias = -0.00005;
            keyLight.shadow.normalBias = 0.02; // Helps significantly with rounded geometry

            // Attach the light to the camera
            camera.add(keyLight);
        }

        function createFloor() {
            const floorGeometry = new THREE.PlaneGeometry(200, 200);
            // A darker, slightly reflective floor material
            const floorMaterial = new THREE.MeshStandardMaterial({
                color: 0x111111,
                roughness: 0.7,
                metalness: 0.2,
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = -2.5;
            floor.receiveShadow = true;
            scene.add(floor);
        }

        function createRealisticMaterials() {
            // Stickers: slightly glossy plastic
            const stickerBase = { roughness: 0.25, metalness: 0.0 };
            for (const [key, colorValue] of Object.entries(COLORS)) {
                if (key !== 'CORE') {
                    stickerMaterials[key] = new THREE.MeshStandardMaterial({ color: colorValue, ...stickerBase });
                }
            }
            // Core: matte, rough black plastic
            coreMaterial = new THREE.MeshStandardMaterial({ color: COLORS.CORE, roughness: 0.85, metalness: 0.0 });
        }

        function createRubiksCube() {
            // RoundedBoxGeometry for realistic edges that catch light highlights
            const cornerRadius = 0.09;
            const segments = 5;
            const geometry = new THREE.RoundedBoxGeometry(CUBE_SIZE, CUBE_SIZE, CUBE_SIZE, segments, cornerRadius);

            for (let x = -1; x <= 1; x++) {
                for (let y = -1; y <= 1; y++) {
                    for (let z = -1; z <= 1; z++) {
                        const materials = [
                            x === 1 ? stickerMaterials.R : coreMaterial,
                            x === -1 ? stickerMaterials.L : coreMaterial,
                            y === 1 ? stickerMaterials.U : coreMaterial,
                            y === -1 ? stickerMaterials.D : coreMaterial,
                            z === 1 ? stickerMaterials.F : coreMaterial,
                            z === -1 ? stickerMaterials.B : coreMaterial,
                        ];
                        const cubie = new THREE.Mesh(geometry, materials);
                        cubie.position.set(x * TOTAL_SIZE, y * TOTAL_SIZE, z * TOTAL_SIZE);
                        // Cubies must cast AND receive shadows for self-shadowing realism
                        cubie.castShadow = true;
                        cubie.receiveShadow = true;
                        cubies.push(cubie);
                        scene.add(cubie);
                    }
                }
            }
        }

        // --- MOVE LOGIC (Standard) ---
        const MOVES = { 'R': { axis: 'x', val: 1 }, 'L': { axis: 'x', val: -1 }, 'U': { axis: 'y', val: 1 }, 'D': { axis: 'y', val: -1 }, 'F': { axis: 'z', val: 1 }, 'B': { axis: 'z', val: -1 } };
        function queueMove(face, dir, record = true) { moveQueue.push({ face, dir, record }); }
        function processQueue() { if (!isAnimating && moveQueue.length > 0) { const m = moveQueue.shift(); performMove(m.face, m.dir, m.record); } }
        function performMove(face, dir, record) {
            isAnimating = true;
            const md = MOVES[face];
            const active = cubies.filter(c => Math.abs(c.position[md.axis] - (md.val * TOTAL_SIZE)) < 0.1);
            pivot.rotation.set(0, 0, 0); pivot.position.set(0, 0, 0);
            active.forEach(c => pivot.attach(c));
            let angle = -Math.PI / 2 * dir; if (['L', 'D', 'B'].includes(face)) angle = -angle;
            new TWEEN.Tween(pivot.rotation).to({ [md.axis]: angle }, 250).easing(TWEEN.Easing.Quadratic.InOut)
                .onComplete(() => {
                    pivot.updateMatrixWorld();
                    active.forEach(c => {
                        scene.attach(c);
                        c.position.set(...['x', 'y', 'z'].map(ax => Math.round(c.position[ax] / TOTAL_SIZE) * TOTAL_SIZE));
                        c.rotation.set(...['x', 'y', 'z'].map(ax => Math.round(c.rotation[ax] / (Math.PI / 2)) * (Math.PI / 2)));
                    });
                    pivot.rotation.set(0, 0, 0);
                    if (record) moveHistory.push({ face, dir });
                    isAnimating = false;
                }).start();
        }

        // --- AUTOMATION ---
        function scrambleCube() { if (isAnimating) return; for (let i = 0; i < 22; i++) queueMove(['U', 'D', 'L', 'R', 'F', 'B'][Math.floor(Math.random() * 6)], Math.random() > 0.5 ? 1 : -1, true); }
        function solveCube() { if (moveHistory.length === 0) return; while (moveHistory.length > 0) { const last = moveHistory.pop(); queueMove(last.face, -last.dir, false); } }
        function applyPattern(t) {
            const seq = t === 'checkerboard' ? [['R', 1], ['R', 1], ['L', 1], ['L', 1], ['U', 1], ['U', 1], ['D', 1], ['D', 1], ['F', 1], ['F', 1], ['B', 1], ['B', 1]] :
                t === 'centerswap' ? [['U', 1], ['D', -1], ['R', 1], ['L', -1], ['F', 1], ['B', -1], ['U', 1], ['D', -1]] : [];
            seq.forEach(m => queueMove(m[0], m[1], true));
        }

        function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
        function animate(time) { requestAnimationFrame(animate); TWEEN.update(time); controls.update(); processQueue(); renderer.render(scene, camera); }

        init();
    </script>
</body>

</html>